
[![C Sharp](https://img.shields.io/badge/-C%20Sharp-&?labelColor=3E434A&colorB=73BF44&logo=Microsoft)](https://github.com/dotnet/roslyn)

## Directory

* **[ex01_single_port_calibration.cs](./ex01_single_port_calibration.cs)**  
This example shows how a user might perform a single port calibration (SOL) using one of the manual calibration standard options. Note that this example uses the bird_vector_network_analyzer.py driver code also featured in this location.
* **[ex02_two_port_calibration.cs](./ex02_two_port_calibration.cs)**  
This example shows how a user might perform a 2-port calibration (SOLT) using one of the manual calibration standard options.
* **[ex03_characterize_antenna.cs](./ex03_characterize_antenna.cs)**  
This example shows how a user can measure return loss, VSWR, and impedance values (via Smith Chart) to aid in characterizing an antenna. It is expected that the operator will have already performed at least a single port (SOL) measurement calibration, but the code also shows how port extensions might be used to account for connectors added after the cal. For more information on antenna characterization, see the application note featured on the [Vector Network Analyzers](https://birdrf.com/Products/Analyzers/VNA.aspx) landing page at birdrf.com that covers this topic.
* **[ex04_triggered_return_loss_sweep.cs](./ex04_triggered_return_loss_sweep.cs)**  
This example shows how to use remote commands to perform configure the VNA for a triggered sweep of return loss (S11). Measurements are then acquired from marker points and returned to the user.
* **[ex05_two_port_calibration_using_ecal_module.cs](./ex05_two_port_calibration_using_ecal_module.cs)**  
This example shows how to use remote commands to perform a two port calibration on the vector network analyzer using the ECal (electronic calibration) module. You will note that in comparison to the manual 2-port calibration, the coding is simpler which aligns with the simplicity and limited connections to the ECal standard/module. 
* **[ex06_limit_test_on_return_loss_sweep_of_bandpass_filter.cs](./ex06_limit_test_on_return_loss_sweep_of_bandpass_filter.cs)**  
This example shows how to use remote commands to perform the bandpass filter characterization steps that are covered in the associated application note featured on the VNA landing pages on birdrf.com. This includes defining the frequency range of interest; measuring return loss, VSWR, and insertion loss at select points using markers; enabling the limit test for the return loss trace defining the test region and making limit lines and pass/fail indicators visible in the software UI as well as reporting the pass/fail status over the instrument bus. Marker search is also used. For more information on filter characterization, see the application note featured on the [Vector Network Analyzers](https://birdrf.com/Products/Analyzers/VNA.aspx) landing page at birdrf.com that covers this topic.
* **[ex07_bandwidth_search_on_insertion_loss_sweep_of_bandpass_filter.cs](./ex07_bandwidth_search_on_insertion_loss_sweep_of_bandpass_filter.cs)**  
This example shows how to use remote commands to perform the bandpass filter characterization steps that are covered in the associated application note featured on the VNA landing pages on birdrf.com. Specifically, this includes defining the frequency range of interest, measuring insertion loss at select points using markers; enabling the bandwidth search to help evaluate the capability of the bandpass filter inserted between the two test ports. For more information on filter characterization, see the application note featured on the [Vector Network Analyzers](https://birdrf.com/Products/Analyzers/VNA.aspx) landing page at birdrf.com that covers this topic.
* **[ex08_save_and_recall_setups.cs](./ex08_save_and_recall_setups.cs)**  
This example shows how to use remote commands to perform save and recall of user setups. The state type is first specifed, helping to point out to the user that calibration and data items can be preserved along with the instrument setup. The setup is saved to file. A preset is then called to return to system defaults, eliminating all prior configurations. Then the state is recalled.